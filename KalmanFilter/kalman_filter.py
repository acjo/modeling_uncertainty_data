import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import inv, norm, solve

class KalmanFilter(object):

    def __init__(self, F, Q, H, R, u):
        """
        Initialize the dynamical system models.

        Parameters
        ----------
        F : ndarray of shape (n,n)
            The state transition model.
        Q : ndarray of shape (n,n)
            The covariance matrix for the state noise.
        H : ndarray of shape (m,n)
            The observation model.
        R : ndarray of shape (m,m)
            The covariance matric for observation noise.
        u : ndarray of shape (n,)
            The control vector.
        """
        # set all attributes
        self.F = F
        self.Q = Q
        self.H = H
        self.R = R
        self.u = u

    def evolve(self, x0, N):
        """
        Compute the first N states and observations generated by the Kalman system.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state.
        N : integer
            The number of time steps to evolve.

        Returns
        -------
        states : ndarray of shape (n,N)
            The i-th column gives the i-th state.
        obs : ndarray of shape (m,N)
            The i-th column gives the i-th observation.
        """
        # initialize observations and states
        n = x0.size
        m = self.R.shape[0]
        states = np.empty((n, N))
        obs = np.empty((m, N))

        # initialize state and observation means
        state_mean = np.zeros(n)
        obs_mean = np.zeros(m)

        # calculate initial state and observations
        states[:, 0] = x0
        v = np.random.multivariate_normal(mean=obs_mean, cov=self.R)
        obs[:, 0] = self.H@x0 + v

        # iterate and calculate all states and observations
        for k in range(N-1):
            w = np.random.multivariate_normal(mean=state_mean, cov=self.Q)
            states[:, k+1] = self.F@states[:, k] + self.u + w
            v = np.random.multivariate_normal(mean=obs_mean, cov=self.R)
            obs[:, k+1] = self.H@states[:, k+1] + v

        return states, obs

    def estimate(self, x0, P0, z, return_norms = False):
        """
        Compute the state estimates using the kalman filter.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state estimate.
        P0 : ndarray of shape (n,n)
            The initial error covariance matrix.
        z : ndarray of shape(m,N)
            Sequence of N observations (each column is an observation).

        Returns
        -------
        out : ndarray of shape (n,N)
            Sequence of state estimates (each column is an estimate).
        norms: list of floats of length N
            Gives the norm of the error matrix for each estimate.
        """
        # initialize necessary variables
        n = x0.size
        _ , N = z.shape
        out = np.empty((n, N+1))
        # set initial states and norms
        out[:, 0] = x0
        P = P0.copy()
        I = np.eye(n)

        # Enter if we want to return the norms
        if return_norms:
            norms = []
            norms.append(norm(P))

            for k in range(N):
                # get predictions
                x_predict = self.F@out[:, k] + self.u
                P_predict = (self.F @ P @ self.F.T) + self.Q
                # now update
                y_tilde = z[:, k] - self.H @ x_predict
                S = self.H @ P_predict @ self.H.T + self.R
                K= P_predict @ self.H.T @ inv(S)
                out[:, k+1] = x_predict + K @ y_tilde
                P = (I - K @ self.H)@P_predict
                norms.append(norm(P))

            return out[:, 1:], norms[1:]

        # if we just want to return the state estimates
        else:

            for k in range(N):
                # get predictions
                x_predict = self.F@out[:, k] + self.u
                P_predict = (self.F @ P @ self.F.T) + self.Q
                # now update
                y_tilde = z[:, k] - self.H @ x_predict
                S = self.H @ P_predict @ self.H.T + self.R
                K= P_predict @ self.H.T @ inv(S)
                out[:, k+1] = x_predict + K @ y_tilde
                P = (I - K @ self.H)@P_predict

            return out[:, 1:]

    def predict(self, x, k):
        """
        Predict the next k states in the absence of observations.

        Parameters
        ----------
        x : ndarray of shape (n,)
            The current state estimate.
        k : integer
            The number of states to predict.

        Returns
        -------
        out : ndarray of shape (n,k)
            The next k predicted states.
        """

        n = x.shape[0]
        out = np.empty((n, k+1))

        out[:, 0] = x

        for i in range(1, k+1):
            out[:, i] = self.F@out[:, i-1] + self.u

        return out[:, 1:]

    def rewind(self, x, k):
        """
        Predict the states from time 0 through k-1 in the absence of observations.

        Parameters
        ----------
        x : ndarray of shape (n,)
            The state estimate at time k.
        k : integer
            The current time step.

        Returns
        -------
        out : ndarray of shape (n,k)
            The predicted states from time 0 up through k-1 (in that order).
        """
        n = x.shape[0]
        out = np.empty((n, k))

        Finv = inv(self.F)

        for i in range(k-1, -1, -1):
            if i == k-1:
                out[:, i] = Finv@(x - self.u)
                #out[:, i] = solve(self.F, x - self.u)
            else:
                out[:, i] = Finv@(out[:, i+1] - self.u)
                #out[:, i] = solve(self.F, out[:, i+1] - self.u)

        return out

def problem2():
    """
    Instantiate and retrun a KalmanFilter object with the transition and observation
    models F and H, along with the control vector u, corresponding to the
    projectile. Assume that the noise covariances are given by
    Q = 0.1 · I4
    R = 5000 · I2.

    Return the KalmanFilter Object
    """
    # define model
    Q = 0.1*np.eye(4)
    R = 5000.*np.eye(2)
    g = 9.8
    dt = 0.1

    F = np.array([[1, 0, dt, 0],
                  [0, 1, 0, dt],
                  [0, 0, 1, 0],
                  [0, 0, 0, 1]])

    H = np.array([[1, 0, 0, 0],
                  [0, 1, 0, 0]])

    u = np.array([0, 0, 0, -dt*g])

    # return Kalman Filter
    return KalmanFilter(F, Q, H, R, u)

def problem3(x0 = np.array([0, 0, 300, 600]), N=1250, plot=True):
    """
    Simulate the true and observed trajectory of a projectile given the provided initial state.
    """

    # get Kalman filter
    KF = problem2()

    # get states and observations
    states, obs =  KF.evolve(x0, N)

    if plot:
        # plot
        fig = plt.figure(figsize=(10, 10))
        fig.set_dpi(150)
        ax = fig.add_subplot(211)
        ax.plot(states[0], states[1], 'b-')
        ax.set_xlabel(r'$s_x$')
        ax.set_ylabel(r'$s_y$')
        ax.set_title('states')
        ax = fig.add_subplot(212)
        ax.plot(obs[0], obs[1], 'r.', markersize=0.7, alpha=0.4)
        ax.set_xlabel(r'$s_x$')
        ax.set_ylabel(r'$s_y$')
        ax.set_title('observations')
        plt.show()

        return

    else:

        return KF, states, obs


def problem5(x0 = np.array([0, 0, 300, 600]), N=1250, plot=True, start=201, end=801):
    """
    Calculate an initial state estimate xb200. Using the initial state estimate,
    P200 and your Kalman Filter, compute the next 600 state estimates.
    Plot these state estimates as a smooth green
    curve together with the radar observations (as red dots) and the entire
    true state sequence (as blue curve).
    """

    # get kalman filter, states, and observations
    dt = 0.1
    KF, states, obs = problem3(x0 = x0, N=N, plot=False)


    # define initial states and number of states to evolve
    P0 = 10**6 * KF.Q

    # get initial state to run Kalman on
    x0_kalman = np.array([obs[0, 200],
                          obs[1, 200],
                          np.mean(np.diff(obs[0, 200:208]))/dt,
                          np.mean(np.diff([obs[1, 200:208]]))/dt])

    # states to run the Kalman filter on
    z = obs[:, start:end]

    # run Kalman Filter
    out = KF.estimate(x0_kalman, P0, z, return_norms = False)

    # now we plot
    if plot:

        fig, axs = plt.subplots(1, 2, constrained_layout=True, figsize=(10, 10))
        fig.set_dpi(150)
        ax = axs[0]

        # plot overall estimation
        ax.plot(states[0], states[1], 'b-', label='States')
        ax.plot(obs[0], obs[1], 'r.', markersize=1, alpha=0.7, label='Observations')
        ax.plot(out[0], out[1], 'g-', label='Kalman Filter Estimation')
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_title('Entire Path')
        ax.legend(loc='best')
        # zoom in
        ax = axs[1]
        ax.plot(states[0, 230:300], states[1, 230:300], 'b-', label='States')
        ax.plot(obs[0, 230:300], obs[1, 230:300], 'r.', markersize=1, alpha=0.7, label='Observations')
        ax.plot(out[0, 30:100], out[1, 30:100], 'g-', label='Kalman Filter Estimation')
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_title('Zoomed in View')
        ax.legend(loc='best')
        plt.show()

        return

    else:

        return KF, states, obs, out[:, -1]

def problem7():
    """
    Using the final state estimate xb800 that you obtained in Problem 5,
    predict the future states of the projectile until it hits the ground.
    Plot the actual state sequence together with the predicted state sequence
    (as a yellow curve), and observe how near the prediction is to the actual
    point of impact.
    """

    # get states, obs, and last estimate from problem 5
    KF, states, obs, out = problem5(plot=False, start=201, end=800)

    # forward estimate
    pred = KF.predict(out, 450)

    #now we plot
    fig, axs = plt.subplots(1, 2, constrained_layout=True, figsize=(10, 10))

    # find indexes where y state / prediction is closest to zero
    state_index = 0
    dist = np.inf
    for j in range(1200, 1250):
        if np.abs(states[1, j]) < dist:
            dist = np.abs(states[1, j])
            state_index = j

    estimate_index = 0
    dist = np.inf
    for j in range(400, 450):
        if np.abs(pred[1, j]) < dist:
            dist = np.abs(pred[1, j])
            estimate_index = j

    # plot state sequence and predicted state sequence
    ax = axs[0]
    ax.plot(states[0], states[1], 'b-', label = 'states')
    ax.plot(pred[0], pred[1], 'y-', label='prediction')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.legend(loc='best')
    ax.set_title('State prediction')

    ax = axs[1]
    ax.plot(states[0, 1200:1250], states[1, 1200:1250], 'b-', label='states')
    ax.plot(pred[0, 400:450], pred[1, 400:450], 'y-', label='prediction')
    ax.set_xlim([int(np.floor(np.min([states[0, state_index], pred[0, estimate_index]]))) - 50,
                int(np.ceil(np.max([states[0, state_index], pred[0, estimate_index]]))) + 50])
    ax.set_ylim([0, 100])
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.legend(loc='best')
    ax.set_title('State prediction zoomed in view')
    plt.show()

    return


def problem9():
    """
     Using your state estimate xb250, predict the point of origin of the
     projectile along with all states leading up to time step 250.
     Plot these predicted states (in cyan) together with the original state
     sequence. Repeat the prediction starting with xb600.
     """

    # run Kalman Filter
    KF, states, obs, out = problem5(plot=False, start=200, end=250)
    #out = KF.estimate(x0_kalman, P0, z, return_norms = False)

    # rewind to get our estimate
    estimate = KF.rewind(out, 275)



    #now we plot
    fig, axs = plt.subplots(1, 2, constrained_layout=True, figsize=(10, 10))

    # find indexes where y state / prediction is closest to zero
    state_index = 0

    estimate_index = 0
    dist = np.inf
    for j in range(estimate.shape[1]):
        if np.abs(estimate[1, j]) < dist:
            dist = np.abs(estimate[1, j])
            estimate_index = j

    # plot state sequence and predicted state sequence
    ax = axs[0]
    ax.plot(states[0], states[1], 'b-', label = 'states')
    ax.plot(estimate[0, estimate_index:], estimate[1, estimate_index:], 'y-', label='prediction')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.legend(loc='best')
    ax.set_title('State prediction')

    ax = axs[1]
    ax.plot(states[0, :350], states[1, :350], label='states')
    ax.plot(estimate[0], estimate[1], 'y-', label='prediction')
    #ax.set_xlim([-150, 150])
    ax.set_xlim([int(np.floor(np.min([states[0, state_index], estimate[0, estimate_index]]))) - 50,
                int(np.ceil(np.max([states[0, state_index], estimate[0, estimate_index]]))) + 50])
    ax.set_ylim([0, 100])
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.legend(loc='best')
    ax.set_title('State prediction zoomed in view')

    plt.suptitle(r'State estimate with $\widehat{x}_{250}$')
    plt.show()

    #####################################
    # repeat the same process for x600
    #####################################

    KF, states, obs, out = problem5(plot=False, start=200, end=600)

    # rewind to get our estimate
    estimate = KF.rewind(out, 625)


    # find indexes where y state / prediction is closest to zero
    state_index = 0

    estimate_index = 0
    dist = np.inf
    for j in range(estimate.shape[1]):
        if np.abs(estimate[1, j]) < dist:
            dist = np.abs(estimate[1, j])
            estimate_index = j

    #now we plot
    fig, axs = plt.subplots(1, 2, constrained_layout=True, figsize=(10, 10))

    # plot state sequence and predicted state sequence
    ax = axs[0]
    ax.plot(states[0], states[1], 'b-', label = 'states')
    ax.plot(estimate[0, estimate_index:], estimate[1, estimate_index:], 'y-', label='prediction')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.legend(loc='best')
    ax.set_title('State prediction')

    ax = axs[1]
    ax.plot(states[0, :600], states[1, :600], label='states')
    ax.plot(estimate[0], estimate[1], 'y-', label='prediction')
    #ax.set_xlim([-100, 250])
    ax.set_xlim([int(np.floor(np.min([states[0, state_index], estimate[0, estimate_index]]))) - 50,
                int(np.ceil(np.max([states[0, state_index], estimate[0, estimate_index]]))) + 50])
    ax.set_ylim([0, 100])
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.legend(loc='best')
    ax.set_title('State prediction zoomed in view')

    plt.suptitle(r'State estimate with $\widehat{x}_{600}$')
    plt.show()

def main(key, verbose=False):

    if key == "1":
        if verbose:
            print("Testing problem 1.")

        Q = 0.1*np.eye(4)
        R = 5000.*np.eye(2)
        g = 9.8
        dt = 0.1

        F = np.array([[1, 0, dt, 0],
                      [0, 1, 0, dt],
                      [0, 0, 1, 0],
                      [0, 0, 0, 1]])

        H = np.array([[1, 0, 0, 0],
                  [0, 1, 0, 0]])

        u = np.array([0, 0, 0, -dt*g])
        KF = KalmanFilter(F, Q, H, R, u)

        assert np.allclose(F, KF.F)
        assert np.allclose(Q, KF.Q)
        assert np.allclose(H, KF.H)
        assert np.allclose(R, KF.R)
        assert np.allclose(u, KF.u)

        if verbose:
            print('Problem 1 tests passed.')

    elif key == "2":
        if verbose:
            print('Testing problem 2.')

        KF = problem2()

        Q = 0.1*np.eye(4)
        R = 5000.*np.eye(2)
        g = 9.8
        dt = 0.1

        F = np.array([[1, 0, dt, 0],
                      [0, 1, 0, dt],
                      [0, 0, 1, 0],
                      [0, 0, 0, 1]])

        H = np.array([[1, 0, 0, 0],
                  [0, 1, 0, 0]])

        u = np.array([0, 0, 0, -dt*g])
        KF1 = KalmanFilter(F, Q, H, R, u)
        assert np.allclose(KF1.F, KF.F)
        assert np.allclose(KF1.Q, KF.Q)
        assert np.allclose(KF1.H, KF.H)
        assert np.allclose(KF1.R, KF.R)
        assert np.allclose(KF1.u, KF.u)

        if verbose:
            print('Problem 2 tests passed.')

    elif key == "3":
        if verbose:
            print('Testing problem 3.')

        problem3()

    elif key == "5":
        if verbose:
            print('Testing problems 4 and 5.')

        problem5()

        if verbose:
            print('Problems 4 and 5 test complete.')


    elif key == "7":
        if verbose:
            print('Testing problems 6 and 7.')

        problem7()

        if verbose:
            print('Problems 6 and 7 test complete.')

    elif key == "9":
        if verbose:
            print('Testing problems 8 and 9.')

        problem9()

        if verbose:
            print('Problems 8 and 9 test complete.')

    else:
        raise ValueError('Incomplete problem specification.')


if __name__ == "__main__":

    if len(sys.argv) == 2:
        main(sys.argv[1])

    elif len(sys.argv) == 3:
        if sys.argv[-1] == "--verbose":
            main(sys.argv[1], verbose=True)

    else:
        raise ValueError("Incorrect command line arguments")




